#!/usr/bin/env python3
"""Regenerate workflow dropdowns from Maintenance indexes.

Contract
- Reads only:
  - maintenance-state/modules_index.csv
  - maintenance-state/workorders_index.csv
- Rewrites only delimited blocks in:
  - .github/workflows/verify_modules.yml
  - .github/workflows/orchestrator.yml

Markers (must exist exactly once per file)
- AUTOGENERATED:MODULE_OPTIONS
- AUTOGENERATED:PLATFORM_WORKORDERS

The script is idempotent: re-running with unchanged indexes produces no diff.
"""

from __future__ import annotations

import csv
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple


@dataclass(frozen=True)
class Block:
    begin: str
    end: str


MODULE_BLOCK = Block(
    begin="# AUTOGENERATED:MODULE_OPTIONS:BEGIN",
    end="# AUTOGENERATED:MODULE_OPTIONS:END",
)
WORKORDER_BLOCK = Block(
    begin="# AUTOGENERATED:PLATFORM_WORKORDERS:BEGIN",
    end="# AUTOGENERATED:PLATFORM_WORKORDERS:END",
)


def _read_csv_rows(path: Path) -> List[dict]:
    with path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        if reader.fieldnames is None:
            raise ValueError(f"CSV missing header: {path}")
        rows: List[dict] = []
        for r in reader:
            rows.append({k: (v if v is not None else "") for k, v in r.items()})
        return rows


def _require_columns(path: Path, rows: List[dict], required: List[str]) -> None:
    if not rows:
        # Empty is allowed, but still must have been parseable.
        return
    missing = [c for c in required if c not in rows[0]]
    if missing:
        raise ValueError(f"{path} missing required columns: {missing}")


def _load_module_ids(repo_root: Path) -> List[str]:
    p = repo_root / "maintenance-state" / "modules_index.csv"
    if not p.exists():
        raise FileNotFoundError(f"Missing {p} (run Maintenance)")
    rows = _read_csv_rows(p)
    _require_columns(p, rows, ["module_id"])
    mids: List[str] = []
    for r in rows:
        mid = str(r.get("module_id", "") or "").strip()
        if not mid:
            continue
        mids.append(mid)
    mids = sorted(set(mids))
    return mids


def _load_platform_workorder_ids(repo_root: Path) -> List[str]:
    p = repo_root / "maintenance-state" / "workorders_index.csv"
    if not p.exists():
        raise FileNotFoundError(f"Missing {p} (run Maintenance)")
    rows = _read_csv_rows(p)
    _require_columns(p, rows, ["tenant_id", "work_order_id", "enabled"])

    out: List[str] = []
    for r in rows:
        tid = str(r.get("tenant_id", "") or "").strip()
        wid = str(r.get("work_order_id", "") or "").strip()
        enabled = str(r.get("enabled", "") or "").strip().lower() == "true"
        if not wid:
            continue
        if tid != "00000t":
            continue
        if not enabled:
            continue
        out.append(wid)

    out = sorted(set(out))
    return out


def _find_block(lines: List[str], block: Block) -> Tuple[int, int]:
    begin_idx = [i for i, ln in enumerate(lines) if ln.strip() == block.begin]
    end_idx = [i for i, ln in enumerate(lines) if ln.strip() == block.end]

    if len(begin_idx) != 1 or len(end_idx) != 1:
        raise ValueError(
            f"Block markers must exist exactly once: {block.begin} / {block.end}"
        )
    b = begin_idx[0]
    e = end_idx[0]
    if e <= b:
        raise ValueError(f"Invalid block ordering: {block.begin} appears after {block.end}")
    return b, e


def _indent_of(line: str) -> str:
    return line[: len(line) - len(line.lstrip(" "))]


def _render_options(option_ids: List[str], indent: str) -> List[str]:
    return [f"{indent}- \"{oid}\"\n" for oid in option_ids]


def _replace_block_in_file(path: Path, block: Block, option_ids: List[str]) -> bool:
    original = path.read_text(encoding="utf-8").splitlines(keepends=True)
    b, e = _find_block(original, block)

    # Options lines should match the indentation of the placeholder list item.
    # We take indentation from the line after BEGIN when available, otherwise from BEGIN line.
    base_indent = _indent_of(original[b])
    list_indent = base_indent
    if b + 1 < len(original):
        list_indent = _indent_of(original[b + 1])

    new_lines = []
    new_lines.extend(original[: b + 1])
    new_lines.extend(_render_options(option_ids, list_indent))
    new_lines.extend(original[e:])

    if new_lines == original:
        return False
    path.write_text("".join(new_lines), encoding="utf-8")
    return True


def main() -> int:
    repo_root = Path(__file__).resolve().parents[1]

    modules = _load_module_ids(repo_root)
    workorders = _load_platform_workorder_ids(repo_root)

    changed_any = False

    changed_any |= _replace_block_in_file(
        repo_root / ".github" / "workflows" / "verify_modules.yml",
        MODULE_BLOCK,
        modules,
    )

    changed_any |= _replace_block_in_file(
        repo_root / ".github" / "workflows" / "orchestrator.yml",
        WORKORDER_BLOCK,
        workorders,
    )

    print(f"[maintenance_regen_verify_dropdowns] modules={len(modules)} platform_workorders={len(workorders)} changed={str(changed_any).lower()}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
