# Verification (Platform, Modules, Workorders)

This repository provides three verification workflows that progressively increase execution scope:

1. **Verify Platform**: repository invariants only (no module execution, no workorder execution).
2. **Verify Modules**: executes a *single module* self-test declared in `module.yml`.
3. **Verify Workorders**: executes a *full workorder* end-to-end for the **platform tenant** (`tenant_id=000000`).

The intent is to make verification:
- deterministic (stable selection inputs, stable indexes, stable outputs),
- explicit (no hidden behavior; choices are visible in YAML, indexes, and logs),
- safe by default (platform invariants do not execute tenant workloads).

---

## Role-based responsibilities

### Repository Maintainer (Platform owner / governance)
Owns:
- verification posture and policy (what is required to merge and release),
- Maintenance indexes (inputs to dropdowns),
- correctness of workflow wiring and permissions.

Uses:
- **Verify Platform** to confirm structural invariants after refactors.
- **Maintenance** to regenerate indexes and dropdown lists.

### Module Engineer (internal or external contributor)
Owns:
- `modules/<module_id>/module.yml` contract correctness,
- `testing.self_test` determinism and declared secret requirements,
- module runtime behavior contained to its own folder and ports.

Uses:
- **Verify Modules** to validate a module in isolation.

### QA / Release Manager (verification operator)
Owns:
- executing verification workflows against a specific revision,
- selecting the correct verification scope for the change,
- enforcing that manual overrides are used only when justified.

Uses:
- **Verify Modules** for targeted module validation,
- **Verify Workorders** for a known stable end-to-end run.

---

## Verify Platform

### Responsibility
Confirms repository invariants only:
- indexes are consistent,
- schemas validate,
- workflow prerequisites are present,
- no execution of modules or workorders occurs.

### Workflow
- Workflow file: `.github/workflows/verify_platform.yml`
- Runner entrypoint: `python scripts/verify_platform.py`

### Local equivalent

```bash
set -euo pipefail
python scripts/verify_platform.py
```


### How it is used by Maintenance

`maintenance.yml` calls **Verify Platform** via `workflow_call` after it regenerates indexes and commits derived outputs.
This ensures that repository invariants are re-checked using the same workflow definition used for manual runs.

---

## Verify Modules

### Responsibility
Runs a single module **self-test** (`module.yml: testing.self_test`).

It validates:
- the module exists in the index,
- `module.yml` is parseable and has required fields,
- the self-test can execute deterministically,
- expected outputs exist.

### Workflow
- Workflow file: `.github/workflows/verify_modules.yml`
- Runner entrypoint: `python scripts/verify_module.py --module-id <module_id>`

### Dropdown selection
The workflow provides a dropdown list of module IDs derived from Maintenance.

Source of truth:
- `maintenance-state/modules_index.csv`

Regeneration:
- `python scripts/maintenance_regen_verify_dropdowns.py`

The workflow contains a single delimited block:
- `# AUTOGENERATED:MODULE_OPTIONS:BEGIN` … `# AUTOGENERATED:MODULE_OPTIONS:END`

Only this block is rewritten by the regeneration script.

### Manual override behavior
The workflow supports both dropdown selection and manual override.

Rules:
- If `module_override` (workflow_dispatch) or `module_id_override` (workflow_call) is provided, it takes precedence.
- If the dropdown choice is `__MANUAL__`, an override value is required.

Examples:

1) Use dropdown (no override)
- choose `deliver_email` in the UI

2) Manual override
- set `module_choice=__MANUAL__`
- set `module_override=deliver_email`

### Local equivalent

```bash
set -euo pipefail
python scripts/verify_module.py --module-id deliver_email
```

---

## Verify Workorders

### Responsibility
Executes a real, end-to-end run of a **platform tenant** workorder (`tenant_id=000000`).

It validates:
- deterministic workorder path resolution (global `work_order_id`),
- orchestrator execution (not dry-run),
- billing + publishing + delivery execute "as is" (per current platform behavior),
- failures return non-zero.

### Workflow
- Workflow file: `.github/workflows/verify_workorders.yml`
- Runner entrypoint: `python scripts/verify_workorder.py --work-order-id <work_order_id>`

### Dropdown selection
The dropdown is restricted to enabled platform-tenant workorders.

Source of truth:
- `maintenance-state/workorders_index.csv`

Filter rules applied by dropdown regeneration:
- `tenant_id == "000000"`
- `enabled == true`

Regeneration:
- `python scripts/maintenance_regen_verify_dropdowns.py`

The workflow contains a single delimited block:
- `# AUTOGENERATED:PLATFORM_WORKORDERS:BEGIN` … `# AUTOGENERATED:PLATFORM_WORKORDERS:END`

### Manual override behavior
Rules:
- If `work_order_override` (workflow_dispatch) or `work_order_id_override` (workflow_call) is provided, it takes precedence.
- If the dropdown choice is `__MANUAL__`, an override value is required.

Examples:

1) Use dropdown (no override)
- choose `PlatEm01` in the UI

2) Manual override
- set `work_order_choice=__MANUAL__`
- set `work_order_override=PlatEm01`

### Local equivalent

```bash
set -euo pipefail
python scripts/verify_workorder.py --work-order-id PlatEm01
```

---

## How dropdown lists are generated

Dropdown lists are **derived outputs**.

Inputs (only):
- `maintenance-state/modules_index.csv`
- `maintenance-state/workorders_index.csv`

Generator:
- `scripts/maintenance_regen_verify_dropdowns.py`

Outputs (only):
- Rewrites the delimited blocks in:
  - `.github/workflows/verify_modules.yml`
  - `.github/workflows/verify_workorders.yml`

Operational rule:
- Run **Maintenance** first (to regenerate the indexes).
- Run the dropdown regeneration script second.

This keeps the UI selection lists synchronized with repository state and prevents stale workflow options.

---

## Cleanup model (cache_index + Cache Prune)

### cache_index.csv
`cache_index.csv` is a release-backed registry used for cache lifecycle management.

Canonical location:
- `.billing-state/cache_index.csv` (also used as the released asset `cache_index.csv` under the `billing-state-v1` release tag).

Canonical schema:

```text
place,type,ref,created_at,expires_at
```

Write behavior:
- The orchestrator writes/updates rows when it creates cacheable artifacts.
- Updates are persisted durably (writes are not only in-memory).

### Cache Prune workflow
The Cache Prune workflow is a scheduled or manually triggered cleanup job.

- Workflow file: `.github/workflows/cache-prune.yml`
- Implementation: `platform/cache/prune.py`

Policy requirements (enforced by implementation):
- Reads `cache_index.csv`.
- Deletes expired caches from GitHub Actions cache storage.
- Removes corresponding rows from `cache_index.csv`.
- **Writes nothing else** (no additional evidence files, no manifests).
- No dry-run mode.

Operational model:
1. Workflow downloads the released `cache_index.csv` asset into `.billing-state/`.
2. Pruner deletes expired caches and rewrites `.billing-state/cache_index.csv`.
3. Workflow uploads the updated `cache_index.csv` back to the release (clobber).

Billing and audit posture:
- Billing evidences remain the system-of-record.
- Cache Prune does not produce its own audit ledger; it only maintains the index to prevent unbounded growth.
